{"ast":null,"code":"import { useRef as $eCAIO$useRef, useEffect as $eCAIO$useEffect, useMemo as $eCAIO$useMemo } from \"react\";\nimport { getFocusableTreeWalker as $eCAIO$getFocusableTreeWalker, focusSafely as $eCAIO$focusSafely } from \"@react-aria/focus\";\nimport { focusWithoutScrolling as $eCAIO$focusWithoutScrolling, useEvent as $eCAIO$useEvent, scrollIntoView as $eCAIO$scrollIntoView, mergeProps as $eCAIO$mergeProps, isAppleDevice as $eCAIO$isAppleDevice, isMac as $eCAIO$isMac } from \"@react-aria/utils\";\nimport { useLocale as $eCAIO$useLocale, useCollator as $eCAIO$useCollator } from \"@react-aria/i18n\";\nimport { usePress as $eCAIO$usePress, useLongPress as $eCAIO$useLongPress } from \"@react-aria/interactions\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n* Copyright 2020 Adobe. All rights reserved.\n* This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License. You may obtain a copy\n* of the License at http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software distributed under\n* the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n* OF ANY KIND, either express or implied. See the License for the specific language\n* governing permissions and limitations under the License.\n*/\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $feb5ffebff200149$export$d3e3bd3e26688c04(e) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return (0, $eCAIO$isAppleDevice)() ? e.altKey : e.ctrlKey;\n}\n\nfunction $feb5ffebff200149$export$16792effe837dba3(e) {\n  if ((0, $eCAIO$isMac)()) return e.metaKey;\n  return e.ctrlKey;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\n\n\nconst $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\n\nfunction $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {\n  let {\n    keyboardDelegate: keyboardDelegate,\n    selectionManager: selectionManager,\n    onTypeSelect: onTypeSelect\n  } = options;\n  let state = (0, $eCAIO$useRef)({\n    search: \"\",\n    timeout: null\n  }).current;\n\n  let onKeyDown = e => {\n    let character = $fb3050f43d946246$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) return; // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n\n    if (character === \" \" && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!(\"continuePropagation\" in e)) e.stopPropagation();\n    }\n\n    state.search += character; // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey); // If no key found, search from the top.\n\n    if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) onTypeSelect(key);\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = \"\";\n    }, $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction $fb3050f43d946246$var$getStringForKey(key) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;\n  return \"\";\n}\n\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref: ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === \"replace\",\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized: isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {\n    direction: direction\n  } = (0, $eCAIO$useLocale)();\n\n  let onKeyDown = e => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === \"Tab\") e.preventDefault(); // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n\n    if (!ref.current.contains(e.target)) return;\n\n    const navigateToKey = (key, childFocus) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n        if (e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(key);else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);\n      }\n    };\n\n    switch (e.key) {\n      case \"ArrowDown\":\n        if (delegate.getKeyBelow) {\n          var _delegate_getFirstKey, _delegate_getFirstKey1;\n\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (delegate.getKeyAbove) {\n          var _delegate_getLastKey, _delegate_getLastKey1;\n\n          e.preventDefault();\n          let nextKey1 = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);\n          if (nextKey1 == null && shouldFocusWrap) nextKey1 = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey1);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey2 = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey2, direction === \"rtl\" ? \"first\" : \"last\");\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey3 = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey3, direction === \"rtl\" ? \"last\" : \"first\");\n        }\n\n        break;\n\n      case \"Home\":\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(firstKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n\n        break;\n\n      case \"End\":\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(lastKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n\n        break;\n\n      case \"PageDown\":\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey4 = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey4);\n        }\n\n        break;\n\n      case \"PageUp\":\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey5 = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey5);\n        }\n\n        break;\n\n      case \"a\":\n        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && manager.selectionMode === \"multiple\" && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n\n        break;\n\n      case \"Escape\":\n        e.preventDefault();\n        if (!disallowEmptySelection) manager.clearSelection();\n        break;\n\n      case \"Tab\":\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) ref.current.focus();else {\n            let walker = (0, $eCAIO$getFocusableTreeWalker)(ref.current, {\n              tabbable: true\n            });\n            let next;\n            let last;\n\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) (0, $eCAIO$focusWithoutScrolling)(next);\n          }\n          break;\n        }\n\n    }\n  }; // Store the scroll position so we can restore it later.\n\n\n  let scrollPos = (0, $eCAIO$useRef)({\n    top: 0,\n    left: 0\n  });\n  (0, $eCAIO$useEvent)(scrollRef, \"scroll\", isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = e => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    } // Focus events can bubble through portals. Ignore these events.\n\n\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = key => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      }; // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n\n\n      let relatedTarget = e.relatedTarget;\n\n      var _manager_lastSelectedKey, _manager_firstSelectedKey;\n\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left; // Refocus and scroll the focused item into view if it exists within the scrollable region.\n\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`);\n\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        (0, $eCAIO$focusWithoutScrolling)(element);\n        (0, $eCAIO$scrollIntoView)(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = e => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n\n  const autoFocusRef = (0, $eCAIO$useRef)(autoFocus);\n  (0, $eCAIO$useEffect)(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null; // Check focus strategy to determine which item to focus\n\n      if (autoFocus === \"first\") focusedKey = delegate.getFirstKey();\n      if (autoFocus === \"last\") focusedKey = delegate.getLastKey(); // If there are any selected keys, make the first one the new focus target\n\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) focusedKey = selectedKeys.values().next().value;\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey); // If no default focus key is selected, focus the collection itself.\n\n      if (focusedKey == null && !shouldUseVirtualFocus) (0, $eCAIO$focusSafely)(ref.current);\n    }\n\n    autoFocusRef.current = false; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n\n  (0, $eCAIO$useEffect)(() => {\n    if (!isVirtualized && manager.focusedKey && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`);\n      if (element) (0, $eCAIO$scrollIntoView)(scrollRef.current, element);\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n  let handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target) // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n    }\n\n  };\n  let {\n    typeSelectProps: typeSelectProps\n  } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n  if (!disallowTypeAhead) handlers = (0, $eCAIO$mergeProps)(typeSelectProps, handlers); // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n\n  let tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: { ...handlers,\n      tabIndex: tabIndex\n    }\n  };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nfunction $880e95eb8b93ba9a$export$ecf600387e221c37(options) {\n  let {\n    selectionManager: manager,\n    key: key,\n    ref: ref,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    isVirtualized: isVirtualized,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    focus: focus,\n    isDisabled: isDisabled,\n    onAction: onAction,\n    allowsDifferentPressOrigin: allowsDifferentPressOrigin\n  } = options;\n\n  let onSelect = e => {\n    if (e.pointerType === \"keyboard\" && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === \"none\") return;\n\n      if (manager.selectionMode === \"single\") {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === \"toggle\" || e && ((0, $feb5ffebff200149$export$16792effe837dba3)(e) || e.pointerType === \"touch\" || e.pointerType === \"virtual\")) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  }; // Focus the associated DOM node when this item becomes the focusedKey\n\n\n  (0, $eCAIO$useEffect)(() => {\n    let isFocused = key === manager.focusedKey;\n\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) focus();else (0, $eCAIO$focusSafely)(ref.current);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  isDisabled = isDisabled || manager.isDisabled(key); // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n\n  let itemProps = {};\n  if (!shouldUseVirtualFocus && !isDisabled) itemProps = {\n    tabIndex: key === manager.focusedKey ? 0 : -1,\n\n    onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n\n  };else if (isDisabled) itemProps.onMouseDown = e => {\n    // Prevent focus going to the body when clicking on a disabled item.\n    e.preventDefault();\n  }; // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n  let allowsActions = onAction && !isDisabled;\n  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === \"replace\" ? !allowsSelection : manager.isEmpty);\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === \"replace\";\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = (0, $eCAIO$useRef)(null);\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = (0, $eCAIO$useRef)(false);\n  let hadPrimaryActionOnPressStart = (0, $eCAIO$useRef)(false); // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n\n  let itemPressProps = {};\n\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === \"keyboard\" && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    }; // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n\n\n    if (!allowsDifferentPressOrigin) itemPressProps.onPress = e => {\n      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== \"mouse\") {\n        if (e.pointerType === \"keyboard\" && !$880e95eb8b93ba9a$var$isActionKey()) return;\n        onAction();\n      } else if (e.pointerType !== \"keyboard\") onSelect(e);\n    };else {\n      itemPressProps.onPressUp = e => {\n        if (e.pointerType !== \"keyboard\") onSelect(e);\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n    }\n  } else {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction; // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n\n      if (e.pointerType === \"mouse\" && !hasPrimaryAction || e.pointerType === \"keyboard\" && (!onAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n\n    itemPressProps.onPress = e => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (e.pointerType === \"touch\" || e.pointerType === \"pen\" || e.pointerType === \"virtual\" || e.pointerType === \"keyboard\" && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === \"mouse\" && hadPrimaryActionOnPressStart.current) {\n        if (hasAction) onAction();else onSelect(e);\n      }\n    };\n  }\n\n  if (!isVirtualized) itemProps[\"data-key\"] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $eCAIO$usePress)(itemPressProps); // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n\n  let onDoubleClick = hasSecondaryAction ? e => {\n    if (modality.current === \"mouse\") {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined; // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n\n  let {\n    longPressProps: longPressProps\n  } = (0, $eCAIO$useLongPress)({\n    isDisabled: !longPressEnabled,\n\n    onLongPress(e) {\n      if (e.pointerType === \"touch\") {\n        onSelect(e);\n        manager.setSelectionBehavior(\"toggle\");\n      }\n    }\n\n  }); // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n\n  let onDragStartCapture = e => {\n    if (modality.current === \"touch\" && longPressEnabledOnPressStart.current) e.preventDefault();\n  };\n\n  return {\n    itemProps: (0, $eCAIO$mergeProps)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {\n      onDoubleClick: onDoubleClick,\n      onDragStartCapture: onDragStartCapture\n    }),\n    isPressed: isPressed,\n    isSelected: manager.isSelected(key),\n    isDisabled: isDisabled,\n    allowsSelection: allowsSelection,\n    hasAction: hasAction\n  };\n}\n\nfunction $880e95eb8b93ba9a$var$isActionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === \"Enter\";\n}\n\nfunction $880e95eb8b93ba9a$var$isSelectionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === \" \" || (event === null || event === void 0 ? void 0 : event.code) === \"Space\";\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $2a25aae57d74318e$export$a05409b8bb224a5a {\n  getKeyBelow(key) {\n    key = this.collection.getKeyAfter(key);\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key) {\n    key = this.collection.getKeyBefore(key);\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === \"item\" && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getItem(key) {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n\n  constructor(collection, disabledKeys, ref, collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n}\n\nfunction $982254629710d113$export$b95089534ab7c1fd(props) {\n  let {\n    selectionManager: selectionManager,\n    collection: collection,\n    disabledKeys: disabledKeys,\n    ref: ref,\n    keyboardDelegate: keyboardDelegate,\n    autoFocus: autoFocus,\n    shouldFocusWrap: shouldFocusWrap,\n    isVirtualized: isVirtualized,\n    disallowEmptySelection: disallowEmptySelection,\n    selectOnFocus = selectionManager.selectionBehavior === \"replace\",\n    disallowTypeAhead: disallowTypeAhead,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation: allowsTabNavigation\n  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n\n  let collator = (0, $eCAIO$useCollator)({\n    usage: \"search\",\n    sensitivity: \"base\"\n  });\n  let disabledBehavior = selectionManager.disabledBehavior;\n  let delegate = (0, $eCAIO$useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)(collection, disabledBehavior === \"selection\" ? new Set() : disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator, disabledBehavior]);\n  let {\n    collectionProps: collectionProps\n  } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({\n    ref: ref,\n    selectionManager: selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus: autoFocus,\n    shouldFocusWrap: shouldFocusWrap,\n    disallowEmptySelection: disallowEmptySelection,\n    selectOnFocus: selectOnFocus,\n    disallowTypeAhead: disallowTypeAhead,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation: allowsTabNavigation,\n    isVirtualized: isVirtualized,\n    scrollRef: ref\n  });\n  return {\n    listProps: collectionProps\n  };\n}\n\nexport { $ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection, $880e95eb8b93ba9a$export$ecf600387e221c37 as useSelectableItem, $982254629710d113$export$b95089534ab7c1fd as useSelectableList, $2a25aae57d74318e$export$a05409b8bb224a5a as ListKeyboardDelegate, $fb3050f43d946246$export$e32c88dfddc6e1d8 as useTypeSelect };","map":{"version":3,"sources":["packages/@react-aria/selection/src/index.ts","packages/@react-aria/selection/src/useSelectableCollection.ts","packages/@react-aria/selection/src/utils.ts","packages/@react-aria/selection/src/useTypeSelect.ts","packages/@react-aria/selection/src/useSelectableItem.ts","packages/@react-aria/selection/src/useSelectableList.ts","packages/@react-aria/selection/src/ListKeyboardDelegate.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useSelectableCollection} from './useSelectableCollection';\nexport {useSelectableItem} from './useSelectableItem';\nexport {useSelectableList} from './useSelectableList';\nexport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nexport {useTypeSelect} from './useTypeSelect';\n\nexport type {AriaSelectableCollectionOptions, SelectableCollectionAria} from './useSelectableCollection';\nexport type {AriaSelectableListOptions, SelectableListAria} from './useSelectableList';\nexport type {SelectableItemOptions, SelectableItemStates, SelectableItemAria} from './useSelectableItem';\nexport type {AriaTypeSelectOptions, TypeSelectAria} from './useTypeSelect';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {FocusEvent, Key, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, useEvent} from '@react-aria/utils';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nexport interface AriaSelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>\n}\n\nexport interface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: DOMAttributes\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: AriaSelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {direction} = useLocale();\n\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as Element)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: FocusableElement;\n            let last: FocusableElement;\n            do {\n              last = walker.lastChild() as FocusableElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        focusWithoutScrolling(element);\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n    autoFocusRef.current = false;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && manager.focusedKey && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice} from '@react-aria/utils';\nimport {isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, KeyboardDelegate} from '@react-types/shared';\nimport {Key, KeyboardEvent, useRef} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\nconst TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\n\nexport interface AriaTypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\nexport interface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: DOMAttributes\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: AriaTypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, LongPressEvent, PressEvent} from '@react-types/shared';\nimport {focusSafely} from '@react-aria/focus';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {Key, RefObject, useEffect, useRef} from 'react';\nimport {mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\n\nexport interface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<FocusableElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior`. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: DOMAttributes\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin\n  } = options;\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus && !isDisabled) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  } else if (isDisabled) {\n    itemProps.onMouseDown = (e) => {\n      // Prevent focus going to the body when clicking on a disabled item.\n      e.preventDefault();\n    };\n  }\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n  let allowsActions = onAction && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          onAction();\n        } else if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = (e) => {\n        if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n        (e.pointerType === 'keyboard' && (!onAction || isSelectionKey()))\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          onAction();\n        } else {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStartCapture}\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DOMAttributes, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\nexport interface AriaSelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\nexport interface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: DOMAttributes\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: AriaSelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = selectionManager.selectionBehavior === 'replace',\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let disabledBehavior = selectionManager.disabledBehavior;\n  let delegate = useMemo(() => (\n    keyboardDelegate || new ListKeyboardDelegate(collection, disabledBehavior === 'selection' ? new Set() : disabledKeys, ref, collator)\n  ), [keyboardDelegate, collection, disabledKeys, ref, collator, disabledBehavior]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n    isVirtualized,\n    scrollRef: ref\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}