{"ast":null,"code":"import { useMemo as $cAn5f$useMemo, useEffect as $cAn5f$useEffect } from \"react\";\nimport { useMultipleSelectionState as $cAn5f$useMultipleSelectionState, SelectionManager as $cAn5f$SelectionManager } from \"@react-stately/selection\";\nimport $cAn5f$swchelperssrc_define_propertymjs from \"@swc/helpers/src/_define_property.mjs\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $62967d126f3aa823$export$4007ac09ff9c68ed(props) {\n  let {\n    collection: collection,\n    focusMode: focusMode\n  } = props;\n  let selectionState = (0, $cAn5f$useMultipleSelectionState)(props);\n  let disabledKeys = (0, $cAn5f$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let setFocusedKey = selectionState.setFocusedKey;\n\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === \"cell\" && key != null) {\n      let item = collection.getItem(key);\n\n      if ((item === null || item === void 0 ? void 0 : item.type) === \"item\") {\n        var _children_, _children_1;\n\n        let children = [...item.childNodes];\n        if (child === \"last\") key = (_children_ = children[children.length - 1]) === null || _children_ === void 0 ? void 0 : _children_.key;else key = (_children_1 = children[0]) === null || _children_1 === void 0 ? void 0 : _children_1.key;\n      }\n    }\n\n    setFocusedKey(key, child);\n  }; // Reset focused key if that item is deleted from the collection.\n\n\n  (0, $cAn5f$useEffect)(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n  }, [collection, selectionState]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: new (0, $cAn5f$SelectionManager)(collection, selectionState)\n  };\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nlet $16805b1b18093c5f$var$_Symbol_iterator = Symbol.iterator;\n\nclass $16805b1b18093c5f$export$de3fdf6493c353d {\n  *[$16805b1b18093c5f$var$_Symbol_iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    var _;\n\n    return (_ = [...this.rows][0]) === null || _ === void 0 ? void 0 : _.key;\n  }\n\n  getLastKey() {\n    var _rows_;\n\n    let rows = [...this.rows];\n    return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n  }\n\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  constructor(opts) {\n    (0, $cAn5f$swchelperssrc_define_propertymjs)(this, \"keyMap\", new Map());\n    this.keyMap = new Map();\n    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n    this.rows = [];\n\n    let visit = node => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) node = opts.visitNode(node);\n      this.keyMap.set(node.key, node);\n      let childKeys = new Set();\n      let last;\n\n      for (let child of node.childNodes) {\n        if (child.type === \"cell\" && child.parentKey == null) // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else child.prevKey = null;\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) last.nextKey = null; // Remove deleted nodes and their children from the key map\n\n      if (prevNode) {\n        for (let child1 of prevNode.childNodes) if (!childKeys.has(child1.key)) remove(child1);\n      }\n    };\n\n    let remove = node => {\n      this.keyMap.delete(node.key);\n\n      for (let child of node.childNodes) if (this.keyMap.get(child.key) === child) remove(child);\n    };\n\n    let last;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: \"row-\" + i,\n        type: \"row\",\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      };\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else rowNode.prevKey = null;\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n      last = rowNode;\n    });\n    if (last) last.nextKey = null;\n  }\n\n}\n\nexport { $62967d126f3aa823$export$4007ac09ff9c68ed as useGridState, $16805b1b18093c5f$export$de3fdf6493c353d as GridCollection };","map":{"version":3,"sources":["packages/@react-stately/grid/src/index.ts","packages/@react-stately/grid/src/useGridState.ts","packages/@react-stately/grid/src/GridCollection.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useGridState} from './useGridState';\nexport {GridCollection} from './GridCollection';\n\nexport type {GridStateOptions, GridState} from './useGridState';\n","import {GridCollection} from '@react-types/grid';\nimport {Key, useEffect, useMemo} from 'react';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager,\n  /** Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. */\n  isKeyboardNavigationDisabled: boolean\n}\n\nexport interface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = [...item.childNodes];\n        if (child === 'last') {\n          key = children[children.length - 1]?.key;\n        } else {\n          key = children[0]?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [collection, selectionState]);\n\n  return {\n    collection,\n    disabledKeys,\n    isKeyboardNavigationDisabled: false,\n    selectionManager: new SelectionManager(collection, selectionState)\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from 'react';\n\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}