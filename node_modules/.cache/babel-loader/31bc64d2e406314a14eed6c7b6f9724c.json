{"ast":null,"code":"import { useState as $8D3nr$useState, useMemo as $8D3nr$useMemo, useEffect as $8D3nr$useEffect, useCallback as $8D3nr$useCallback } from \"react\";\nimport { useLayoutEffect as $8D3nr$useLayoutEffect } from \"@react-aria/utils\";\nimport $8D3nr$swchelperssrc_define_propertymjs from \"@swc/helpers/src/_define_property.mjs\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n* Copyright 2020 Adobe. All rights reserved.\n* This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License. You may obtain a copy\n* of the License at http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software distributed under\n* the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n* OF ANY KIND, either express or implied. See the License for the specific language\n* governing permissions and limitations under the License.\n*/\n\nclass $c74cda7d31af1253$export$c84671f46d6a1ca {\n  /**\n  * Returns whether the layout should invalidate in response to\n  * visible rectangle changes. By default, it only invalidates\n  * when the collection view's size changes. Return true always\n  * to make the layout invalidate while scrolling (e.g. sticky headers).\n  */\n  shouldInvalidate(newRect, oldRect) {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n  }\n  /**\n  * This method allows the layout to perform any pre-computation\n  * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n  * Called by the collection view before {@link getVisibleLayoutInfos}\n  * or {@link getLayoutInfo} are called.\n  */\n\n\n  validate(invalidationContext) {}\n  /**\n  * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n  * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n  * @param point The point at which the drag occurred.\n  */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n  * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n  * to reject the drop. The dropped items will be inserted before the resulting target.\n  * @param point The point at which the drop occurred.\n  */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n  * Returns the starting attributes for an animated insertion.\n  * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n  * The default implementation just returns its input.\n  *\n  * @param layoutInfo The proposed LayoutInfo for this view.\n  */\n\n\n  getInitialLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n  /**\n  * Returns the ending attributes for an animated removal.\n  * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n  * to the one returned by this method. The default implementation returns its input.\n  *\n  * @param layoutInfo The original LayoutInfo for this view.\n  */\n\n\n  getFinalLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n  /**\n  * Returns a copy of the LayoutInfo.\n  */\n  copy() {\n    let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    res.zIndex = this.zIndex;\n    res.allowOverflow = this.allowOverflow;\n    return res;\n  }\n  /**\n  * @param type A string representing the view type. Should be `'item'` for item views.\n                          Other types are used by supplementary views.\n  * @param key The unique key for this view.\n  * @param rect The rectangle describing the size and position of this view.\n  */\n\n\n  constructor(type, key, rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $3041db3296945e6e$export$baf26146a414f24a {\n  /**\n  * Returns a copy of this point.\n  */\n  copy() {\n    return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n  }\n  /**\n  * Checks if two points are equal.\n  */\n\n\n  equals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n  /**\n  * Returns true if this point is the origin.\n  */\n\n\n  isOrigin() {\n    return this.x === 0 && this.y === 0;\n  }\n\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $60423f92c7f9ad87$export$c79fc6492f3af13d {\n  /**\n  * The maximum x-coordinate in the rectangle.\n  */\n  get maxX() {\n    return this.x + this.width;\n  }\n  /**\n  * The maximum y-coordinate in the rectangle.\n  */\n\n\n  get maxY() {\n    return this.y + this.height;\n  }\n  /**\n  * The area of the rectangle.\n  */\n\n\n  get area() {\n    return this.width * this.height;\n  }\n  /**\n  * The top left corner of the rectangle.\n  */\n\n\n  get topLeft() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.y);\n  }\n  /**\n  * The top right corner of the rectangle.\n  */\n\n\n  get topRight() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.y);\n  }\n  /**\n  * The bottom left corner of the rectangle.\n  */\n\n\n  get bottomLeft() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.x, this.maxY);\n  }\n  /**\n  * The bottom right corner of the rectangle.\n  */\n\n\n  get bottomRight() {\n    return new (0, $3041db3296945e6e$export$baf26146a414f24a)(this.maxX, this.maxY);\n  }\n  /**\n  * Returns whether this rectangle intersects another rectangle.\n  * @param rect - The rectangle to check.\n  */\n\n\n  intersects(rect) {\n    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n  }\n  /**\n  * Returns whether this rectangle fully contains another rectangle.\n  * @param rect - The rectangle to check.\n  */\n\n\n  containsRect(rect) {\n    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n  }\n  /**\n  * Returns whether the rectangle contains the given point.\n  * @param point - The point to check.\n  */\n\n\n  containsPoint(point) {\n    return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n  }\n  /**\n  * Returns the first corner of this rectangle (from top to bottom, left to right)\n  * that is contained in the given rectangle, or null of the rectangles do not intersect.\n  * @param rect - The rectangle to check.\n  */\n\n\n  getCornerInRect(rect) {\n    for (let key of [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]) {\n      if (rect.containsPoint(this[key])) return key;\n    }\n\n    return null;\n  }\n\n  equals(rect) {\n    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n\n  pointEquals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  sizeEquals(size) {\n    return this.width === size.width && this.height === size.height;\n  }\n  /**\n  * Returns the union of this Rect and another.\n  */\n\n\n  union(other) {\n    let x = Math.min(this.x, other.x);\n    let y = Math.min(this.y, other.y);\n    let width = Math.max(this.maxX, other.maxX) - x;\n    let height = Math.max(this.maxY, other.maxY) - y;\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, width, height);\n  }\n  /**\n  * Returns the intersection of this Rect with another.\n  * If the rectangles do not intersect, an all zero Rect is returned.\n  */\n\n\n  intersection(other) {\n    if (!this.intersects(other)) return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, 0, 0);\n    let x = Math.max(this.x, other.x);\n    let y = Math.max(this.y, other.y);\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, Math.min(this.maxX, other.maxX) - x, Math.min(this.maxY, other.maxY) - y);\n  }\n  /**\n  * Returns a copy of this rectangle.\n  */\n\n\n  copy() {\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n  }\n\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n  /**\n  * Returns a copy of this size.\n  */\n  copy() {\n    return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n  }\n  /**\n  * Returns whether this size is equal to another one.\n  */\n\n\n  equals(other) {\n    return this.width === other.width && this.height === other.height;\n  }\n  /**\n  * The total area of the Size.\n  */\n\n\n  get area() {\n    return this.width * this.height;\n  }\n\n  constructor(width = 0, height = 0) {\n    this.width = width;\n    this.height = height;\n  }\n\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nlet $ad1d98aa8f0c31b4$var$KEY = 0;\n\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n  /**\n  * Prepares the view for reuse. Called just before the view is removed from the DOM.\n  */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n\n  constructor(virtualizer) {\n    this.virtualizer = virtualizer;\n    this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n  }\n\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/*\n* Copyright 2020 Adobe. All rights reserved.\n* This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License. You may obtain a copy\n* of the License at http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software distributed under\n* the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n* OF ANY KIND, either express or implied. See the License for the specific language\n* governing permissions and limitations under the License.\n*/\n// use high res timer if available\n\n\nlet $3eb131dcf37ad5f8$var$perf = typeof window !== \"undefined\" ? window.performance : null; // @ts-ignore\n\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\n\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n  let canceled = false;\n  let raf_id;\n  let promise = new Promise(resolve => {\n    let start = $3eb131dcf37ad5f8$var$getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1e12 !== $3eb131dcf37ad5f8$var$getTime() > 1e12;\n      if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime(); // check if we're done\n\n      let delta = t - start;\n\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new (0, $3041db3296945e6e$export$baf26146a414f24a)(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n        if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n      }\n    });\n  });\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n  return t;\n}\n\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nfunction $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n  let res = new Set();\n\n  for (let key of a.keys()) if (!b.has(key)) res.add(key);\n\n  return res;\n}\n\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n  let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n  let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n  let toUpdate = new Set();\n\n  for (let key of a.keys()) if (b.has(key)) toUpdate.add(key);\n\n  return {\n    toRemove: toRemove,\n    toAdd: toAdd,\n    toUpdate: toUpdate\n  };\n}\n\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f(...iterators) {\n  for (let iterator of iterators) yield* iterator;\n}\n\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n  let res = {};\n\n  for (let key in object) res[object[key]] = key;\n\n  return res;\n}\n\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n  if (a === b) return true;\n  if (a.size !== b.size) return false;\n\n  for (let key of a) {\n    if (!b.has(key)) return false;\n  }\n\n  return true;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $364191b3decf3697$var$RollingAverage {\n  addSample(sample) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n\n  constructor() {\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"count\", 0);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"value\", 0);\n  }\n\n}\n\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n  setVisibleRect(rect) {\n    let time = performance.now() - this.startTime;\n\n    if (time < 500) {\n      this.averageTime.addSample(time);\n      if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) this.averagePerf.addSample(time);\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o1 = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n      this.overscanX.addSample(o1);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n\n  constructor() {\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"startTime\", 0);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"averagePerf\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"averageTime\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"velocity\", new (0, $3041db3296945e6e$export$baf26146a414f24a)(5, 5));\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"overscanX\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"overscanY\", new $364191b3decf3697$var$RollingAverage());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"visibleRect\", new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)());\n  }\n\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nclass $8e135e531d8dcb66$export$febc5573c75cefb0 {\n  constructor() {\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"level\", 0);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"actions\", []);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"animated\", true);\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"initialMap\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"finalMap\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"initialLayoutInfo\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"finalLayoutInfo\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"removed\", new Map());\n    (0, $8D3nr$swchelperssrc_define_propertymjs)(this, \"toRemove\", new Map());\n  }\n\n}\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n  _setContentSize(size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n  /**\n  * Get the size of the scrollable content.\n  */\n\n\n  get contentSize() {\n    return this._contentSize;\n  }\n  /**\n  * Get the collection view's currently visible rectangle.\n  */\n\n\n  get visibleRect() {\n    return this._visibleRect;\n  }\n  /**\n  * Set the collection view's currently visible rectangle.\n  */\n\n\n  set visibleRect(rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect, forceUpdate = false) {\n    let current = this._visibleRect; // Ignore if the rects are equal\n\n    if (rect.equals(current)) return;\n    if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n\n    this._visibleRect = rect;\n    if (shouldInvalidate) this.relayout({\n      offsetChanged: !rect.pointEquals(current),\n      sizeChanged: !rect.sizeEquals(current)\n    });else this.updateSubviews(forceUpdate);\n  }\n\n  get collection() {\n    return this._collection;\n  }\n\n  set collection(data) {\n    this._setData(data);\n  }\n\n  _setData(data) {\n    if (data === this._collection) return;\n    if (this._collection) this._runTransaction(() => {\n      this._collection = data;\n    }, this.transitionDuration > 0);else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n  /**\n  * Reloads the data from the data source and relayouts the collection view.\n  * Does not animate any changes. Equivalent to re-assigning the same data source\n  * to the collection view.\n  */\n\n\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n  /**\n  * Returns the item with the given key.\n  */\n\n\n  getItem(key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n\n\n  get persistedKeys() {\n    return this._persistedKeys;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n\n\n  set persistedKeys(persistedKeys) {\n    if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n  /** Returns whether the given key, or an ancestor, is persisted. */\n\n\n  isPersistedKey(key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) return true; // If not, check if the key is an ancestor of any of the persisted keys.\n\n    for (let k of this._persistedKeys) while (k != null) {\n      let layoutInfo = this.layout.getLayoutInfo(k);\n      if (!layoutInfo) break;\n      k = layoutInfo.parentKey;\n      if (k === key) return true;\n    }\n\n    return false;\n  }\n  /**\n  * Get the collection view's layout.\n  */\n\n\n  get layout() {\n    return this._layout;\n  }\n  /**\n  * Set the collection view's layout.\n  */\n\n\n  set layout(layout) {\n    this.setLayout(layout);\n  }\n  /**\n  * Sets the collection view's layout, optionally with an animated transition\n  * from the current layout to the new layout.\n  * @param layout The layout to switch to.\n  * @param animated Whether to animate the layout change.\n  */\n\n\n  setLayout(layout, animated = false) {\n    if (layout === this._layout) return;\n\n    let applyLayout = () => {\n      if (this._layout) // @ts-ignore\n        this._layout.virtualizer = null;\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  _getReuseType(layoutInfo, content) {\n    if (layoutInfo.type === \"item\" && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n      let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n      return {\n        type: type,\n        reuseType: reuseType\n      };\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo) {\n    let content = this.getItem(layoutInfo.key);\n\n    let {\n      reuseType: reuseType\n    } = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n\n    return view;\n  }\n\n  _renderView(reusableView) {\n    let {\n      type: type,\n      key: key\n    } = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  _renderContent(type, content) {\n    let cached = this._renderedContent.get(content);\n\n    if (cached != null) return cached;\n    let rendered = this.delegate.renderView(type, content);\n    if (content) this._renderedContent.set(content, rendered);\n    return rendered;\n  }\n  /**\n  * Returns an array of all currently visible views, including both\n  * item views and supplementary views.\n  */\n\n\n  get visibleViews() {\n    return Array.from(this._visibleViews.values());\n  }\n  /**\n  * Gets the visible view for the given type and key. Returns null if\n  * the view is not currently visible.\n  *\n  * @param key The key of the view to retrieve.\n  */\n\n\n  getView(key) {\n    return this._visibleViews.get(key) || null;\n  }\n  /**\n  * Returns an array of visible views matching the given type.\n  * @param type The view type to find.\n  */\n\n\n  getViewsOfType(type) {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n  /**\n  * Returns the key for the given view. Returns null\n  * if the view is not currently visible.\n  */\n\n\n  keyForView(view) {\n    if (view && view.layoutInfo) return view.layoutInfo.key;\n    return null;\n  }\n  /**\n  * Returns the key for the item view currently at the given point.\n  */\n\n\n  keyAtPoint(point) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect); // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n    }\n\n    return null;\n  }\n  /**\n  * Cleanup for when the Virtualizer will be unmounted.\n  */\n\n\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n  /**\n  * Triggers a layout invalidation, and updates the visible subviews.\n  */\n\n\n  relayout(context = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return; // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n  /**\n  * Performs a relayout immediately. Prefer {@link relayout} over this method\n  * where possible, since it coalesces multiple layout passes in the same tick.\n  */\n\n\n  relayoutNow(context = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null; // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n\n      context = { ...this._invalidationContext,\n        ...context\n      };\n    } // Reset the invalidation context\n\n\n    this._invalidationContext = null; // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n\n    if (!this.layout || !this._collection || this._scrollAnimation) return;\n\n    let scrollAnchor = this._getScrollAnchor(); // Trigger the beforeLayout hook, if provided\n\n\n    if (typeof context.beforeLayout === \"function\") context.beforeLayout(); // Validate the layout\n\n    this.layout.validate(context);\n\n    this._setContentSize(this.layout.getContentSize()); // Trigger the afterLayout hook, if provided\n\n\n    if (typeof context.afterLayout === \"function\") context.afterLayout(); // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n\n    let visibleRect = this.getVisibleRect();\n\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n    let hasLayoutUpdates = false;\n\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n    } else hasLayoutUpdates = this.updateSubviews(context.contentChanged); // Apply layout infos, unless this is coming from an animated transaction\n\n\n    if (!(context.transaction && context.animated)) this._applyLayoutInfos(); // Wait for animations, and apply the afterAnimation hook, if provided\n\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions(); // Reset scroll position after animations (see above comment).\n\n\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {\n            x: x,\n            y: y\n          } = this.getVisibleRect();\n\n          this._resetAnimatedContentOffset();\n\n          this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n        }\n\n        if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n      }; // Sometimes the animation takes slightly longer than expected.\n\n\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n  }\n  /**\n  * Corrects DOM order of visible views to match item order of collection.\n  */\n\n\n  _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) return;\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n\n      this._children.delete(view);\n\n      this._children.add(view);\n    }\n  }\n\n  _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  _getScrollAnchor() {\n    if (!this.anchorScrollPosition) return null;\n    let visibleRect = this.getVisibleRect(); // Ask the delegate to provide a scroll anchor, if possible\n\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let key1 = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {\n            key: key1,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    } // No need to anchor the scroll position if it is at the top\n\n\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null; // Find a view with a visible corner that has the smallest distance to the top of the collection view\n\n    let cornerAnchor = null;\n\n    for (let [key2, view] of this._visibleViews) {\n      let layoutInfo1 = view.layoutInfo;\n\n      if (layoutInfo1 && layoutInfo1.rect.area > 0) {\n        let corner1 = layoutInfo1.rect.getCornerInRect(visibleRect);\n\n        if (corner1) {\n          let offset1 = layoutInfo1.rect[corner1].y - visibleRect.y;\n          if (!cornerAnchor || offset1 < cornerAnchor.offset) cornerAnchor = {\n            key: key2,\n            layoutInfo: layoutInfo1,\n            corner: corner1,\n            offset: offset1\n          };\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  _restoreScrollAnchor(scrollAnchor, context) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      var _context_transaction;\n\n      let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect() {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  _getLayoutInfoMap(rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map();\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) layoutInfo = layoutInfo.copy();\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) return;\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate; // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({\n        toAdd: toAdd,\n        toRemove: toRemove,\n        toUpdate: toUpdate\n      } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) continue;\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) toUpdate.delete(key);else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {\n            reuseType: reuseType\n          } = this._getReuseType(view.layoutInfo, item);\n\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      } // We are done if the sets are equal\n\n\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) this._applyLayoutInfos();\n        return;\n      }\n    } // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n\n\n    let removed = new Set();\n\n    for (let key1 of toRemove.keys()) {\n      let view1 = this._visibleViews.get(key1);\n\n      if (view1) {\n        removed.add(view1);\n\n        this._visibleViews.delete(key1); // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n\n\n        if (this._transaction) this._transaction.toRemove.set(key1, view1);else this.reuseView(view1);\n      }\n    }\n\n    for (let key2 of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key2);\n      let view2; // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key2)) layoutInfo = this._transaction.initialLayoutInfo.get(key2);\n        view2 = this._transaction.toRemove.get(key2);\n\n        if (view2) {\n          this._transaction.toRemove.delete(key2);\n\n          this._applyLayoutInfo(view2, layoutInfo);\n        }\n      }\n\n      if (!view2) {\n        // Create or reuse a view for this row\n        view2 = this.getReusableView(layoutInfo); // Add the view to the DOM if needed\n\n        if (!removed.has(view2)) this._children.add(view2);\n      }\n\n      this._visibleViews.set(key2, view2);\n\n      removed.delete(view2);\n    }\n\n    for (let key3 of toUpdate) {\n      let view3 = currentlyVisible.get(key3);\n\n      this._renderedContent.delete(key3);\n\n      this._renderView(view3);\n    } // Remove the remaining rows to delete from the DOM\n\n\n    if (!this._transaction) this.removeViews(removed);\n\n    this._correctItemOrder();\n\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n\n    if (hasLayoutUpdates) requestAnimationFrame(() => {\n      // If we're in a transaction, apply animations to visible views\n      // and \"to be removed\" views, which animate off screen.\n      if (this._transaction) requestAnimationFrame(() => this._applyLayoutInfos());\n    });\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) this._overscanManager.collectMetrics();\n  }\n\n  _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n\n    for (let view of this._children) {\n      var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n\n      if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n      if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n    }\n\n    let buildTree = (parent, views) => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(parent, view, children, childViews => buildTree(view, childViews));\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  _applyLayoutInfo(view, layoutInfo) {\n    if (view.layoutInfo === layoutInfo) return false;\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  _applyLayoutInfos() {\n    let updated = false; // Apply layout infos to visible views\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n\n      if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n    } // Apply final layout infos for views that will be removed\n\n\n    if (this._transaction) {\n      for (let view1 of this._transaction.toRemove.values()) {\n        let cur1 = view1.layoutInfo;\n\n        if ((cur1 === null || cur1 === void 0 ? void 0 : cur1.key) != null) {\n          let layoutInfo1 = this.layout.getLayoutInfo(cur1.key);\n          if (this._applyLayoutInfo(view1, layoutInfo1)) updated = true;\n        }\n      }\n\n      for (let view2 of this._transaction.removed.values()) {\n        let cur2 = view2.layoutInfo;\n        let layoutInfo2 = this._transaction.finalLayoutInfo.get(cur2.key) || cur2;\n        layoutInfo2 = this.layout.getFinalLayoutInfo(layoutInfo2.copy());\n        if (this._applyLayoutInfo(view2, layoutInfo2)) updated = true;\n      }\n    }\n\n    if (updated) this._flushVisibleViews();\n  }\n\n  _hasLayoutUpdates() {\n    if (!this._transaction) return false;\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) return true;\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if ( // Uses equals rather than pointEquals so that width/height changes are taken into account\n      !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n    }\n\n    return false;\n  }\n\n  reuseView(view) {\n    view.prepareForReuse();\n\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove) {\n    for (let view of toRemove) this._children.delete(view);\n  }\n\n  updateItemSize(key, size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) return; // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n\n      return;\n    } // @ts-ignore\n\n\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) this.relayout();\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n\n    this._correctItemOrder();\n\n    this._flushVisibleViews();\n  }\n\n  _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n\n      this._applyLayoutInfos();\n    }\n  }\n  /**\n  * Scrolls the item with the given key into view, optionally with an animation.\n  * @param key The key of the item to scroll into view.\n  * @param duration The duration of the scroll animation.\n  */\n\n\n  scrollToItem(key, options) {\n    // key can be 0, so check if null or undefined\n    if (key == null) return;\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) return;\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) x = minX;else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) y = minY;else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n    }\n\n    return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n  }\n  /**\n  * Performs an animated scroll to the given offset.\n  * @param offset - The offset to scroll to.\n  * @param duration The duration of the animation.\n  * @returns A promise that resolves when the animation is complete.\n  */\n\n\n  scrollTo(offset, duration = 300) {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n\n      this._scrollAnimation = null;\n    } // Set the content offset synchronously if the duration is zero\n\n\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n    this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), offset => {\n      this._setContentOffset(offset);\n    });\n\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null; // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n\n      for (let [key, size] of this._sizeUpdateQueue) this.updateItemSize(key, size);\n\n      this._sizeUpdateQueue.clear();\n\n      this.relayout();\n\n      this._processTransactionQueue();\n\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  _runTransaction(action, animated) {\n    this._startTransaction();\n\n    if (this._nextTransaction) this._nextTransaction.actions.push(action);\n\n    this._endTransaction(animated);\n  }\n\n  _startTransaction() {\n    if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0)();\n    this._nextTransaction.level++;\n  }\n\n  _endTransaction(animated) {\n    if (!this._nextTransaction) return false; // Save whether the transaction should be animated.\n\n    if (animated != null) this._nextTransaction.animated = animated; // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n\n    if (--this._nextTransaction.level > 0) return false; // Do nothing for empty transactions\n\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    } // Default animations to true\n\n\n    if (this._nextTransaction.animated == null) this._nextTransaction.animated = true; // Enqueue the transaction\n\n    this._transactionQueue.push(this._nextTransaction);\n\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n\n    return true;\n  }\n\n  _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) return;\n\n    let next = this._transactionQueue.shift();\n\n    if (next) this._performTransaction(next);\n  }\n\n  _getContentRect() {\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  _performTransaction(transaction) {\n    this._transaction = transaction;\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true); // Apply the actions that occurred during this transaction\n\n        for (let action of transaction.actions) action();\n      },\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n\n          this._setupTransactionAnimations(transaction);\n        } else this._transaction = null;\n      },\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())) {\n          this._children.delete(view);\n\n          this.reuseView(view);\n        }\n        this._transaction = null; // Ensure DOM order is correct for accessibility after animations are complete\n\n        this._correctItemOrder();\n\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  _setupTransactionAnimations(transaction) {\n    let {\n      initialMap: initialMap,\n      finalMap: finalMap\n    } = transaction; // Store initial and final layout infos for animations\n\n    for (let [key, layoutInfo] of initialMap) if (finalMap.has(key)) // Store the initial layout info for use during animations.\n      transaction.initialLayoutInfo.set(key, layoutInfo);else // This view was removed. Store the layout info for use\n      // in Layout#getFinalLayoutInfo during animations.\n      transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo); // Get initial layout infos for views that were added\n\n\n    for (let [key1, layoutInfo1] of finalMap) if (!initialMap.has(key1)) {\n      let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo1.copy());\n      transaction.initialLayoutInfo.set(key1, initialLayoutInfo);\n    } // Figure out which views were removed.\n\n\n    for (let [key2, view] of this._visibleViews) // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n    // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n    // added, removed... etc in a loop.\n    if (!finalMap.has(key2) && view.layoutInfo.rect.width > 0) {\n      transaction.removed.set(key2, view);\n\n      this._visibleViews.delete(key2); // In case something weird happened, where we have a view but no\n      // initial layout info, use the one attached to the view.\n\n\n      if (view.layoutInfo) {\n        if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n      }\n    }\n  }\n\n  constructor(options = {}) {\n    this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();\n    this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n    this._persistedKeys = new Set();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    var _options_transitionDuration; // Set options from passed object if given\n\n\n    this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n\n    for (let key of [\"delegate\", \"size\", \"layout\", \"collection\"]) if (options[key]) this[key] = options[key];\n  }\n\n}\n\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n  let [visibleViews, setVisibleViews] = (0, $8D3nr$useState)([]);\n  let [contentSize, setContentSize] = (0, $8D3nr$useState)(new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)());\n  let [isAnimating, setAnimating] = (0, $8D3nr$useState)(false);\n  let [isScrolling, setScrolling] = (0, $8D3nr$useState)(false);\n  let virtualizer = (0, $8D3nr$useMemo)(() => new (0, $38b9490c1cca8fc4$export$89be5a243e59c4b2)(), []);\n  virtualizer.delegate = {\n    setVisibleViews: setVisibleViews,\n\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n\n    setContentSize: setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n  (0, $8D3nr$useLayoutEffect)(() => {\n    virtualizer.afterRender();\n  }); // eslint-disable-next-line arrow-body-style\n\n  (0, $8D3nr$useEffect)(() => {\n    return () => virtualizer.willUnmount(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  let setVisibleRect = (0, $8D3nr$useCallback)(rect => {\n    virtualizer.visibleRect = rect;\n  }, [virtualizer]);\n  let startScrolling = (0, $8D3nr$useCallback)(() => {\n    virtualizer.startScrolling();\n    setScrolling(true);\n  }, [virtualizer]);\n  let endScrolling = (0, $8D3nr$useCallback)(() => {\n    virtualizer.endScrolling();\n    setScrolling(false);\n  }, [virtualizer]);\n  let state = (0, $8D3nr$useMemo)(() => ({\n    virtualizer: virtualizer,\n    visibleViews: visibleViews,\n    setVisibleRect: setVisibleRect,\n    contentSize: contentSize,\n    isAnimating: isAnimating,\n    isScrolling: isScrolling,\n    startScrolling: startScrolling,\n    endScrolling: endScrolling\n  }), [virtualizer, visibleViews, setVisibleRect, contentSize, isAnimating, isScrolling, startScrolling, endScrolling]);\n  return state;\n}\n\nexport { $c74cda7d31af1253$export$c84671f46d6a1ca as Layout, $d7fd61009c21d0bb$export$7e0eeb9da702a085 as LayoutInfo, $3041db3296945e6e$export$baf26146a414f24a as Point, $60423f92c7f9ad87$export$c79fc6492f3af13d as Rect, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec as Size, $ad1d98aa8f0c31b4$export$1a5223887c560441 as ReusableView, $fc0b13b484ac1194$export$1505db82fe357e65 as useVirtualizerState };","map":{"version":3,"sources":["packages/@react-stately/virtualizer/src/index.ts","packages/@react-stately/virtualizer/src/Layout.ts","packages/@react-stately/virtualizer/src/LayoutInfo.ts","packages/@react-stately/virtualizer/src/Point.ts","packages/@react-stately/virtualizer/src/Rect.ts","packages/@react-stately/virtualizer/src/Size.ts","packages/@react-stately/virtualizer/src/ReusableView.ts","packages/@react-stately/virtualizer/src/useVirtualizerState.ts","packages/@react-stately/virtualizer/src/Virtualizer.ts","packages/@react-stately/virtualizer/src/tween.ts","packages/@react-stately/virtualizer/src/utils.ts","packages/@react-stately/virtualizer/src/OverscanManager.ts","packages/@react-stately/virtualizer/src/Transaction.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {InvalidationContext} from './types';\nexport type {VirtualizerState} from './useVirtualizerState';\nexport type {RectCorner} from './Rect';\n\nexport {Layout} from './Layout';\nexport {LayoutInfo} from './LayoutInfo';\nexport {Point} from './Point';\nexport {Rect} from './Rect';\nexport {Size} from './Size';\nexport {ReusableView} from './ReusableView';\nexport {useVirtualizerState} from './useVirtualizerState';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {InvalidationContext} from './types';\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\n// import {Point} from './Point';\nimport {Rect} from './Rect';\nimport {Size} from './Size';\nimport {Virtualizer} from './Virtualizer';\n// import { DragTarget, DropTarget } from '@react-types/shared';\n\n/**\n * [CollectionView]{@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how\n * to position and style them. However, layouts do not create the views themselves directly. Instead,\n * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,\n * such as its position and size. The {@link CollectionView} is then responsible for creating the actual\n * views as needed, based on this layout information.\n *\n * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the\n * two methods listed below. All other methods can be optionally overridden to implement custom behavior.\n *\n * @see {@link getVisibleLayoutInfos}\n * @see {@link getLayoutInfo}\n */\nexport abstract class Layout<T extends object> {\n  /** The CollectionView the layout is currently attached to. */\n  virtualizer: Virtualizer<T, any, any>;\n\n  /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */\n  shouldInvalidate(newRect: Rect, oldRect: Rect): boolean {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width\n        || newRect.height !== oldRect.height;\n  }\n\n  /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */\n  validate(invalidationContext: InvalidationContext<T, any>) {} // eslint-disable-line @typescript-eslint/no-unused-vars\n\n  /**\n   * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.\n   * Should be implemented by subclasses.\n   * @param rect The rectangle that should contain the returned LayoutInfo objects.\n   */\n  abstract getVisibleLayoutInfos(rect: Rect): LayoutInfo[];\n\n  /**\n   * Returns a {@link LayoutInfo} for the given key.\n   * Should be implemented by subclasses.\n   * @param key The key of the LayoutInfo to retrieve.\n   */\n  abstract getLayoutInfo(key: Key): LayoutInfo;\n\n  /**\n   * Returns size of the content. By default, it returns collectionView's size.\n   */\n  abstract getContentSize(): Size;\n\n  /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */\n  getInitialLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n\n  /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */\n  getFinalLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {Rect} from './Rect';\n\n/**\n * Instances of this lightweight class are created by {@link Layout} subclasses\n * to represent each view in the {@link CollectionView}. LayoutInfo objects describe\n * various properties of a view, such as its position and size, and style information.\n * The collection view uses this information when creating actual views to display.\n */\nexport class LayoutInfo {\n  /**\n   * A string representing the view type. Should be `'item'` for item views.\n   * Other types are used by supplementary views.\n   */\n  type: string;\n\n  /**\n   * A unique key for this view. For item views, it should match the content key.\n   */\n  key: Key;\n\n  /**\n   * The key for a parent layout info, if any.\n   */\n  parentKey: Key | null;\n\n  /**\n   * The rectangle describing the size and position of this view.\n   */\n  rect: Rect;\n\n  /**\n   * Whether the size is estimated. `false` by default.\n   */\n  estimatedSize: boolean;\n\n  /**\n   * Whether the layout info sticks to the viewport when scrolling.\n   */\n  isSticky: boolean;\n\n  /**\n   * The view's opacity. 1 by default.\n   */\n  opacity: number;\n\n  /**\n   * A CSS transform string to apply to the view. `null` by default.\n   */\n  transform: string | null;\n\n  /**\n   * The z-index of the view. 0 by default.\n   */\n  zIndex: number;\n\n  /**\n   * Whether the layout info allows its contents to overflow its container.\n   * @default false\n   */\n  allowOverflow: boolean;\n\n  /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */\n  constructor(type: string, key: Key, rect: Rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n  /**\n   * Returns a copy of the LayoutInfo.\n   */\n  copy(): LayoutInfo {\n    let res = new LayoutInfo(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    res.zIndex = this.zIndex;\n    res.allowOverflow = this.allowOverflow;\n    return res;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Point {\n  /** The x-coordinate of the point. */\n  x: number;\n\n  /** The y-coordinate of the point. */\n  y: number;\n\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Returns a copy of this point.\n   */\n  copy(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * Checks if two points are equal.\n   */\n  equals(point: Point): boolean {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  /**\n   * Returns true if this point is the origin.\n   */\n  isOrigin(): boolean {\n    return this.x === 0 && this.y === 0;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Size} from './Size';\n\nexport type RectCorner = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n\n/**\n * Represents a rectangle.\n */\nexport class Rect {\n  /** The x-coordinate of the rectangle. */\n  x: number;\n\n  /** The y-coordinate of the rectangle. */\n  y: number;\n\n  /** The width of the rectangle. */\n  width: number;\n\n  /** The height of the rectangle. */\n  height: number;\n\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * The maximum x-coordinate in the rectangle.\n   */\n  get maxX(): number {\n    return this.x + this.width;\n  }\n\n  /**\n   * The maximum y-coordinate in the rectangle.\n   */\n  get maxY(): number {\n    return this.y + this.height;\n  }\n\n  /**\n   * The area of the rectangle.\n   */\n  get area(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * The top left corner of the rectangle.\n   */\n  get topLeft(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * The top right corner of the rectangle.\n   */\n  get topRight(): Point {\n    return new Point(this.maxX, this.y);\n  }\n\n  /**\n   * The bottom left corner of the rectangle.\n   */\n  get bottomLeft(): Point {\n    return new Point(this.x, this.maxY);\n  }\n\n  /**\n   * The bottom right corner of the rectangle.\n   */\n  get bottomRight(): Point {\n    return new Point(this.maxX, this.maxY);\n  }\n\n  /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  intersects(rect: Rect): boolean {\n    return this.x <= rect.x + rect.width\n        && rect.x <= this.x + this.width\n        && this.y <= rect.y + rect.height\n        && rect.y <= this.y + this.height;\n  }\n\n  /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  containsRect(rect: Rect): boolean {\n    return this.x <= rect.x\n        && this.y <= rect.y\n        && this.maxX >= rect.maxX\n        && this.maxY >= rect.maxY;\n  }\n\n  /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */\n  containsPoint(point: Point): boolean {\n    return this.x <= point.x\n        && this.y <= point.y\n        && this.maxX >= point.x\n        && this.maxY >= point.y;\n  }\n\n  /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */\n  getCornerInRect(rect: Rect): RectCorner | null {\n    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {\n      if (rect.containsPoint(this[key])) {\n        return key as RectCorner;\n      }\n    }\n\n    return null;\n  }\n\n  equals(rect: Rect) {\n    return rect.x === this.x\n        && rect.y === this.y\n        && rect.width === this.width\n        && rect.height === this.height;\n  }\n\n  pointEquals(point: Point | Rect) {\n    return this.x === point.x\n        && this.y === point.y;\n  }\n\n  sizeEquals(size: Size | Rect) {\n    return this.width === size.width\n        && this.height === size.height;\n  }\n\n  /**\n   * Returns the union of this Rect and another.\n   */\n  union(other: Rect) {\n    let x = Math.min(this.x, other.x);\n    let y = Math.min(this.y, other.y);\n    let width = Math.max(this.maxX, other.maxX) - x;\n    let height = Math.max(this.maxY, other.maxY) - y;\n    return new Rect(x, y, width, height);\n  }\n\n  /**\n   * Returns the intersection of this Rect with another.\n   * If the rectangles do not intersect, an all zero Rect is returned.\n   */\n  intersection(other: Rect): Rect {\n    if (!this.intersects(other)) {\n      return new Rect(0, 0, 0, 0);\n    }\n\n    let x = Math.max(this.x, other.x);\n    let y = Math.max(this.y, other.y);\n    return new Rect(\n      x,\n      y,\n      Math.min(this.maxX, other.maxX) - x,\n      Math.min(this.maxY, other.maxY) - y\n    );\n  }\n\n  /**\n   * Returns a copy of this rectangle.\n   */\n  copy(): Rect {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Size {\n  width: number;\n  height: number;\n\n  constructor(width = 0, height = 0) {\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Returns a copy of this size.\n   */\n  copy(): Size {\n    return new Size(this.width, this.height);\n  }\n\n  /**\n   * Returns whether this size is equal to another one.\n   */\n  equals(other: Size): boolean {\n    return this.width === other.width\n        && this.height === other.height;\n  }\n\n  /**\n   * The total area of the Size.\n   */\n  get area() {\n    return this.width * this.height;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {Virtualizer} from './Virtualizer';\n\nlet KEY = 0;\n\n/**\n * [CollectionView]{@link CollectionView} creates instances of the [ReusableView]{@link ReusableView} class to\n * represent views currently being displayed. ReusableViews manage a DOM node, handle\n * applying {@link LayoutInfo} objects to the view, and render content\n * as needed. Subclasses must implement the {@link render} method at a\n * minimum. Other methods can be overridden to customize behavior.\n */\nexport class ReusableView<T extends object, V> {\n  /** The CollectionVirtualizer this view is a part of. */\n  virtualizer: Virtualizer<T, V, unknown>;\n\n  /** The LayoutInfo this view is currently representing. */\n  layoutInfo: LayoutInfo | null;\n\n  /** The content currently being displayed by this view, set by the collection view. */\n  content: T;\n\n  rendered: V;\n\n  viewType: string;\n  key: Key;\n\n  constructor(virtualizer: Virtualizer<T, V, unknown>) {\n    this.virtualizer = virtualizer;\n    this.key = ++KEY;\n  }\n\n  /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection} from '@react-types/shared';\nimport {Key, useCallback, useEffect, useMemo, useState} from 'react';\nimport {Layout} from './Layout';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {Virtualizer} from './Virtualizer';\n\ninterface VirtualizerProps<T extends object, V, W> {\n  renderView(type: string, content: T): V,\n  renderWrapper(\n    parent: ReusableView<T, V> | null,\n    reusableView: ReusableView<T, V>,\n    children: ReusableView<T, V>[],\n    renderChildren: (views: ReusableView<T, V>[]) => W[]\n  ): W,\n  layout: Layout<T>,\n  collection: Collection<T>,\n  onVisibleRectChange(rect: Rect): void,\n  getScrollAnchor?(rect: Rect): Key,\n  transitionDuration?: number\n}\n\nexport interface VirtualizerState<T extends object, V, W> {\n  visibleViews: W[],\n  setVisibleRect: (rect: Rect) => void,\n  contentSize: Size,\n  isAnimating: boolean,\n  virtualizer: Virtualizer<T, V, W>,\n  isScrolling: boolean,\n  startScrolling: () => void,\n  endScrolling: () => void\n}\n\nexport function useVirtualizerState<T extends object, V, W>(opts: VirtualizerProps<T, V, W>): VirtualizerState<T, V, W> {\n  let [visibleViews, setVisibleViews] = useState<W[]>([]);\n  let [contentSize, setContentSize] = useState(new Size());\n  let [isAnimating, setAnimating] = useState(false);\n  let [isScrolling, setScrolling] = useState(false);\n  let virtualizer = useMemo(() => new Virtualizer<T, V, W>(), []);\n\n  virtualizer.delegate = {\n    setVisibleViews,\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n\n  useLayoutEffect(() => {\n    virtualizer.afterRender();\n  });\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => virtualizer.willUnmount();\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  let setVisibleRect = useCallback((rect) => {\n    virtualizer.visibleRect = rect;\n  }, [virtualizer]);\n  let startScrolling = useCallback(() => {\n    virtualizer.startScrolling();\n    setScrolling(true);\n  }, [virtualizer]);\n  let endScrolling = useCallback(() => {\n    virtualizer.endScrolling();\n    setScrolling(false);\n  }, [virtualizer]);\n\n  let state = useMemo(() => ({\n    virtualizer,\n    visibleViews,\n    setVisibleRect,\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling,\n    endScrolling\n  }), [\n    virtualizer,\n    visibleViews,\n    setVisibleRect,\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling,\n    endScrolling\n  ]);\n\n  return state;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CancelablePromise, easeOut, tween} from './tween';\nimport {Collection} from '@react-types/shared';\nimport {concatIterators, difference, isSetEqual} from './utils';\nimport {\n  InvalidationContext,\n  ScrollAnchor,\n  ScrollToItemOptions,\n  VirtualizerDelegate,\n  VirtualizerOptions\n} from './types';\nimport {Key} from 'react';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {Transaction} from './Transaction';\n\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\nexport class Virtualizer<T extends object, V, W> {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V, W>;\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n  transitionDuration: number;\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n  anchorScrollPosition: boolean;\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n  anchorScrollPositionAtTop: boolean;\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  shouldOverscan: boolean;\n\n  private _collection: Collection<T>;\n  private _layout: Layout<T>;\n  private _contentSize: Size;\n  private _visibleRect: Rect;\n  private _visibleLayoutInfos: Map<Key, LayoutInfo>;\n  private _reusableViews: {[type: string]: ReusableView<T, V>[]};\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _children: Set<ReusableView<T, V>>;\n  private _invalidationContext: InvalidationContext<T, V> | null;\n  private _overscanManager: OverscanManager;\n  private _persistedKeys: Set<Key>;\n  private _relayoutRaf: number | null;\n  private _scrollAnimation: CancelablePromise<void> | null;\n  private _isScrolling: boolean;\n  private _sizeUpdateQueue: Map<Key, Size>;\n  private _animatedContentOffset: Point;\n  private _transaction: Transaction<T, V> | null;\n  private _nextTransaction: Transaction<T, V> | null;\n  private _transactionQueue: Transaction<T, V>[];\n\n  constructor(options: VirtualizerOptions<T, V, W> = {}) {\n    this._contentSize = new Size;\n    this._visibleRect = new Rect;\n\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n    this._persistedKeys = new Set();\n\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    // Set options from passed object if given\n    this.transitionDuration = options.transitionDuration ?? 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size: Size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset: Point) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n\n  /**\n   * Get the size of the scrollable content.\n   */\n  get contentSize(): Size {\n    return this._contentSize;\n  }\n\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n  get visibleRect(): Rect {\n    return this._visibleRect;\n  }\n\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n  set visibleRect(rect: Rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect: Rect, forceUpdate = false) {\n    let current = this._visibleRect;\n\n    // Ignore if the rects are equal\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection(): Collection<T> {\n    return this._collection;\n  }\n\n  set collection(data: Collection<T>) {\n    this._setData(data);\n  }\n\n  private _setData(data: Collection<T>) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n\n  /**\n   * Returns the item with the given key.\n   */\n  getItem(key: Key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys(): Set<Key> {\n    return this._persistedKeys;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys: Set<Key>) {\n    if (!isSetEqual(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key: Key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) {\n      return true;\n    }\n\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) {\n      while (k != null) {\n        let layoutInfo = this.layout.getLayoutInfo(k);\n        if (!layoutInfo) {\n          break;\n        }\n\n        k = layoutInfo.parentKey;\n\n        if (k === key) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the collection view's layout.\n   */\n  get layout(): Layout<T> {\n    return this._layout;\n  }\n\n  /**\n   * Set the collection view's layout.\n   */\n  set layout(layout: Layout<T>) {\n    this.setLayout(layout);\n  }\n\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n  setLayout(layout: Layout<T>, animated = false) {\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  private _getReuseType(layoutInfo: LayoutInfo, content: T | null) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {type, reuseType};\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let content = this.getItem(layoutInfo.key);\n    let {reuseType} = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0\n      ? reusable.pop()\n      : new ReusableView<T, V>(this);\n\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key} = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n  get visibleViews(): ReusableView<T, V>[] {\n    return Array.from(this._visibleViews.values());\n  }\n\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n  getView(key: Key): ReusableView<T, V> | null {\n    return this._visibleViews.get(key) || null;\n  }\n\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n  getViewsOfType(type: string): ReusableView<T, V>[] {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n  keyForView(view: ReusableView<T, V>): Key | null {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) {\n        return layoutInfo.key;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n  relayout(context: InvalidationContext<T, V> = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    }\n\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n  relayoutNow(context: InvalidationContext<T, V> = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {...this._invalidationContext, ...context};\n    }\n\n    // Reset the invalidation context\n    this._invalidationContext = null;\n\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor();\n\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    }\n\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    }\n\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    }\n\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    }\n\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions();\n\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {x, y} = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      };\n\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n  private _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n\n  private _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  private _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  private _getScrollAnchor(): ScrollAnchor | null {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect();\n\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {key, layoutInfo, corner, offset};\n        }\n      }\n    }\n\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    }\n\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor: ScrollAnchor | null = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || (offset < cornerAnchor.offset)) {\n            cornerAnchor = {key, layoutInfo, corner, offset};\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  private _restoreScrollAnchor(scrollAnchor: ScrollAnchor | null, context: InvalidationContext<T, V>) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      let finalAnchor = context.transaction?.animated\n        ? context.transaction.finalMap.get(scrollAnchor.key)\n        : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = (finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y) - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect(): Rect {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  private _getLayoutInfoMap(rect: Rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({toAdd, toRemove, toUpdate} = difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {reuseType} = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    }\n\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set<ReusableView<T, V>>();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view: ReusableView<T, V> | void;\n\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key) as ReusableView<T, V>;\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  private _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      if (view.layoutInfo?.parentKey != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo?.parentKey)?.push(view);\n      if (!viewsByParentKey.has(view.layoutInfo?.key)) {\n        viewsByParentKey.set(view.layoutInfo?.key, []);\n      }\n    }\n\n    let buildTree = (parent: ReusableView<T, V>, views: ReusableView<T, V>[]): W[] => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(\n        parent,\n        view,\n        children,\n        (childViews) => buildTree(view, childViews)\n      );\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  private _applyLayoutInfo(view: ReusableView<T, V>, layoutInfo: LayoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  private _applyLayoutInfos() {\n    let updated = false;\n\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (cur?.key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        if (cur?.key != null) {\n          let layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if (this._applyLayoutInfo(view, layoutInfo)) {\n            updated = true;\n          }\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  private _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n        // Uses equals rather than pointEquals so that width/height changes are taken into account\n        !cur.rect.equals(layoutInfo.rect) ||\n        cur.opacity !== layoutInfo.opacity ||\n        cur.transform !== layoutInfo.transform\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view: ReusableView<T, V>) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove: Set<ReusableView<T, V>>) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n\n  private _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n  scrollToItem(key: Key, options?: ScrollToItemOptions) {\n    // key can be 0, so check if null or undefined\n    if (key == null) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n  scrollTo(offset: Point, duration: number = 300): Promise<void> {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n\n    this._scrollAnimation = tween(this.visibleRect, offset, duration, easeOut, offset => {this._setContentOffset(offset);});\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  private _runTransaction(action: () => void, animated?: boolean) {\n    this._startTransaction();\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n    this._endTransaction(animated);\n  }\n\n  private _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new Transaction;\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  private _endTransaction(animated?: boolean) {\n    if (!this._nextTransaction) {\n      return false;\n    }\n\n    // Save whether the transaction should be animated.\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    }\n\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    }\n\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n\n    // Default animations to true\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    }\n\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n    return true;\n  }\n\n  private _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  private _getContentRect(): Rect {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  private _performTransaction(transaction: Transaction<T, V>) {\n    this._transaction = transaction;\n\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        }\n\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null;\n\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  private _setupTransactionAnimations(transaction: Transaction<T, V>) {\n    let {initialMap, finalMap} = transaction;\n\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    }\n\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    }\n\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews) {\n      // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n      // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n      // added, removed... etc in a loop.\n      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n        transaction.removed.set(key, view);\n        this._visibleViews.delete(key);\n\n        // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\n\n// use high res timer if available\nlet perf = typeof window !== 'undefined' ? window.performance : null;\n// @ts-ignore\nlet perfNow = perf && (perf.now || perf.webkitNow || perf.msNow || perf.mozNow);\nlet getTime = perfNow ? perfNow.bind(perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\n\nlet fixTs: boolean;\n\nexport interface CancelablePromise<T> extends Promise<T> {\n  cancel(): void\n}\n\nexport function tween(begin, end, duration, ease, fn): CancelablePromise<void> {\n  let canceled = false;\n  let raf_id: number;\n\n  let promise = new Promise(resolve => {\n    let start = getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if (fixTs == null) {\n        fixTs = t > 1e12 !== getTime() > 1e12;\n      }\n\n      if (fixTs) {\n        t = getTime();\n      }\n\n      // check if we're done\n      let delta = t - start;\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new Point(\n          begin.x + diffX * ease(delta / duration),\n          begin.y + diffY * ease(delta / duration)\n        ));\n\n        if (proceed !== false && !canceled) {\n          raf_id = requestAnimationFrame(run);\n        }\n      }\n    });\n  }) as CancelablePromise<void>;\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\n// easing functions\nexport function linearEasing(t) {\n  return t;\n}\n\nexport function easeOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function keyDiff<T>(a: Map<T, any>, b: Map<T, any>): Set<T> {\n  let res = new Set<T>();\n\n  for (let key of a.keys()) {\n    if (!b.has(key)) {\n      res.add(key);\n    }\n  }\n\n  return res;\n}\n\n/**\n * Returns the key difference between two maps. Returns a set of\n * keys to add to and remove from a to make it equal to b.\n * @private\n */\nexport function difference<T>(a: Map<T, any>, b: Map<T, any>) {\n  let toRemove = keyDiff(a, b);\n  let toAdd = keyDiff(b, a);\n  let toUpdate = new Set;\n  for (let key of a.keys()) {\n    if (b.has(key)) {\n      toUpdate.add(key);\n    }\n  }\n  return {toRemove, toAdd, toUpdate};\n}\n\n/**\n * Returns an iterator that yields the items in all of the given iterators.\n * @private\n */\nexport function* concatIterators<T>(...iterators: Iterable<T>[]) {\n  for (let iterator of iterators) {\n    yield* iterator;\n  }\n}\n\n/**\n * Inverts the keys and values of an object.\n * @private\n */\nexport function invert(object) {\n  let res = {};\n  for (let key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n\n/** Returns whether two sets are equal. */\nexport function isSetEqual<T>(a: Set<T>, b: Set<T>): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (let key of a) {\n    if (!b.has(key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Rect} from './Rect';\n\nclass RollingAverage {\n  private count: number = 0;\n  value: number = 0;\n  \n  addSample(sample: number) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n}\n\nexport class OverscanManager {\n  private startTime = 0;\n  private averagePerf = new RollingAverage();\n  private averageTime = new RollingAverage();\n  private velocity = new Point(5, 5);\n  private overscanX = new RollingAverage();\n  private overscanY = new RollingAverage();\n  private visibleRect = new Rect();\n  \n  setVisibleRect(rect: Rect) {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averageTime.addSample(time);\n\n      if (rect.x !== this.visibleRect.x && time > 0) {\n        this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      }\n\n      if (rect.y !== this.visibleRect.y && time > 0) {\n        this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averagePerf.addSample(time);\n    }\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanX.addSample(o);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {ReusableView} from './ReusableView';\n\ntype LayoutInfoMap = Map<Key, LayoutInfo>;\nexport class Transaction<T extends object, V> {\n  level = 0;\n  actions: (() => void)[] = [];\n  animated = true;\n  initialMap: LayoutInfoMap = new Map();\n  finalMap: LayoutInfoMap = new Map();\n  initialLayoutInfo: LayoutInfoMap = new Map();\n  finalLayoutInfo: LayoutInfoMap = new Map();\n  removed: Map<Key, ReusableView<T, V>> = new Map();\n  toRemove: Map<Key, ReusableView<T, V>> = new Map();\n}\n"]},"metadata":{},"sourceType":"module"}